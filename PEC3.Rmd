---
title: "2017 Clinic Dataset Analysis"
subtitle: "Assisted reproduction clinics data from the CDC"
author: "Jorge Vallejo Ortega"
output:
  md_document: default
  pdf_document: default
---
# Foreword
This work is inspired in an exercise from the course 'Software para el análisis de datos' in UOC's degree 'Bioinformática y Bioestadística'.

I am using this to learn the use of the language R, and the tools RStudio, Git and GitHub. This is not a professional level study of assisted reproduction data from clinics in the USA. If you want to have access to such studies, or even the raw data, you can get them from CDC's webpage [ART's Success Rate Data](https://www.cdc.gov/art/artdata/index.html).


## Statement
MARKDOWN will be used for this paper, generating a Pdf report with Knitr in RStudio.

The file with the R code have to be delivered as well.

From a dataset, a statistical study must be carried out using R. The points below can be used as an outline:

### 1. Look for a dataset related with Biostatistics or Bioinformatics.
Must be public data.
Explain source of data and include pertinent references. Justify why that specific dataset has been chosen.

### 2. Display the data.
Using R, display and explain the type of file that has been imported, which variables are included (type, classification,...) and anything else that seems relevant.  
Include snapshots and R commands used for import and display of the data.


### 3. Probe questions.
Make a minimum of six questions that probe the kind of information contained in the dataset.


### 4. Descriptive analysis of the data.
The paper must include a parametric summary of the data and several graphic representations of said data.


### 5. Probability and simulation.
A minimum of three questions answering probability questions and a question corresponding a short simulation model.


### 6. Regression analysis.
A brief regression analysis from the variables in the dataset answering some question of interest.


### 7. Final assessment.
Final assessment from source data and papaer:
Do we have conclussions?
Would be necessary a more advanced analysis?
Would be necessary more data for obtaining another kind of information?


 
# 1. Dataset

I wanted to do something with data from human assisted reproduction techniques. Those are difficult to find as public datasets, I suppose that it is due to privacy issues.

Finally, I found public datasets published by the Centers for Disease Control and Prevention (CDC) with several kinds of data from assisted reproduction clinics in the United States:  
https://www.cdc.gov/art/artdata/index.html

Other datasets from previous years can be downloaded/looked up as well:  
https://www.cdc.gov/art/reports/archive.html


# Datasets downloading

```{r eval = FALSE}

# The code option eval = FALSE prevents this chunk to run. In this way, data WON'T
# be downloaded each time the .Rmd file is knitted to produce a report.
# For allowing this chunk to run, change eval to TRUE.

source_url <- "https://www.cdc.gov/art/artdata/docs/excel/FINAL-2017-Clinic-Table-Dataset.xlsx"

download.file(source_url, destfile = "../datos/FINAL-2017-Clinic-Table-Dataset.xlsx", method = "curl")
```

This is the dataset I am using for this practise study, but we could want to download datasets from previous years to do longitudinal studies:

```{r eval = FALSE}

# The code option eval = FALSE prevents this chunk to run. In this way, data WON'T
# be downloaded each time the .Rmd file is knitted to produce a report.
# For allowing this chunk to run, change eval to TRUE.

years <- c(1995:2015)

url_start1 <- "https://www.cdc.gov/art/excelfiles/clinic_tables_data_"
url_start2 <- "https://www.cdc.gov/art/excelfiles/"
url_start3 <- "https://www.cdc.gov/art/artdata/docs/excel/FINAL-"

file_start1 <- "clinic_tables_data_"
file_start2 <- ""
file_start3 <- "FINAL-"

url_end1 <- ".xls"
url_end2 <- "-clinic-tables-dataset.xls"
url_end3 <- "-clinic-table-dataset.xls"

# This code is rough on the edges, it doesn't take into account when a file
# fails to download.

for (year in years){
  if (year <= 2012){
    url <- paste0(url_start1, year, url_end1)
    destfile <- paste0(file_start1, year, url_end1)
  }
  else if (year == 2013){
    url <- paste0(url_start2, year, url_end2)
    destfile <- paste0(file_start2, year, url_end2)
  }
    else if (year == 2014){
    url <- "https://www.cdc.gov/art/artdata/docs/excel/2014-Clinic-Tables-Data-Dictionary.xls"
    destfile <- "2014-Clinic-Tables-Data-Dictionary.xls"
  }
  else {
    url <- paste0(url_start3, year, url_end3)
    destfile <- paste0(file_start3, year, url_end3)
  }
  
  #cat(url, "\n", destfile, "\n\n") # Cheks that the names of url and files are rightly constructed.
  download.file(url, destfile, method = "curl")
}
```


# 2. Display data

The downloaded file _FINAL-2017-Clinic-Table-Dataset.xlsx_ includes data from assisted reproduction treatments from 448 US clinics, collected during 2017. It is an Excel workbook containing four sheets:

**National Summary Data**. Aggregated data from all the clinics included in the report.  
**National Table Dictionary**. Dictionary-table with the explanation for each variable in the previous table.  
**Clinic Table Data Records**. Tabla with data broke down by clinic.  
**Clinic Table Dictionary**.  Dictionary-table explaining each variable from Clinic Table.  

I am interested in the data broke down by clinic. Therefore, I will import the data from sheets **Clinic Table Dictionary** and **Clinic Table Data Records**.

```{r}
require("xlsx")
clinic_dictionary <- read.xlsx("../datos/FINAL-2017-Clinic-Table-Dataset.xlsx", 4,
                               endRow = 165, encoding = "UTF-8")
# Everything is NA after row 166; row 166 is a comment.

View(clinic_dictionary)

# In Viewer, in the column Age the symbols '>=' are displayed as '=',
# but if we print the column to screen the correct symbols are displayed.

clinic_data <- read.xlsx("../datos/FINAL-2017-Clinic-Table-Dataset.xlsx", 3
                         , encoding = "UTF-8", stringsAsFactors=FALSE)
View(clinic_data)

```

Let's see how each variable has been codified:

```{r}
str(clinic_data, list.len = length(clinic_data))
```


In the structure can be seen a problem from this data source. Percentages and ratios are
coded as text, not as numbers. It will be necessary pre-process the data from the table before we can work with them.

Why numeric variables are detected  as characters. Ratios contain non-numeric symbols ("%", "/", "<"). What's the problem with the rest?

We will order alphabetically each column, see what happens.

First of all, to avoid problems down the line, we will change null values in the table for `NA`:

```{r}
clinic_data[clinic_data==""] <- NA

View(clinic_data)
```

Should we order the values in the columns, we see that there are columns with integers in which the thousands are marked with a comma (`,`).

```{r}
ordenadas <- sapply(clinic_data, function(x) sort(x, na.last = TRUE))

View(ordenadas)

```

Next, we will correct those variables that should be `integer` o `numeric`.

Code adapted from a question in Stack Overflow:
[How to read data when some numbers contain commas as thousand separator?](https://stackoverflow.com/questions/1523126/how-to-read-data-when-some-numbers-contain-commas-as-thousand-separator)

```{r}
# Vectors that refer the columns that should be integers
# and the columns that should be ratios.

integers <- c(7:11, 22:26, 37:41, 82:85, 94:99, 163)
ratios <- c(12:21, 27:36, 42:81, 86:93, 100:154)

# Pre-processing columns with integers deleting "," symbol.
clinic_data[, integers] <- lapply(clinic_data[, integers],
                                  function(x){
                                    as.integer(gsub(",", "", x))
                                  })

str(clinic_data[, integers])
```

Pre-processing the columns with rations is a bit more complex. It is necessary to deal with three different cases:

1) Data as <1%. Since we don't have the real value, what I will do is arbitrarily chose
the value 0.5%, expressed as 0.005 ratio.

2) Data including "%" symbol. Same strategy that we followed with integers;
I will remove the symbol with `gsub`. Besides, I will divide the result by 100, making all numbers a ratio (parts per unit).

3) Data as fractions. Even a bit more complex. I will use regular expressions to isolate numerator and denominator, and will return the result of the division as a ratio.

```{r}
# This function process ratios expressed as fractions.
divide <- function(x){
  numerator <- as.numeric(gsub(" .*$", "", x))
  denominator <- as.numeric(gsub("^.*/ ", "", x))
  return (numerator / denominator)
}

# This is the main functios for processing ratios from characters to numbers.
# Expect the appearance of several warnings of 'NA introduced by coercion' due to multiple # data points represented as 'NA' in characters which the function is unable to deal with.
numerizador <- function(dato){
    ifelse (dato == "<1%", 0.005,
            ifelse ((grepl("%", dato) == TRUE), as.numeric(gsub("%", "", dato))/100,
                    ifelse ((grepl("/", dato)==TRUE), divide(dato), as.numeric(dato))))
}
# The function 'ifelse' is needed for working with vectors of length >1.

# Pre-processing ratios:
clinic_data[, ratios] <- lapply(clinic_data[, ratios], numerizador)
# When using this expression, multiple warnings of 'NAs introduced by coercion' appear.
# I think it is due to "NA" being stored as character strings.
# I haven't been able to correct it yet. It is possible to avoid the raise of the warning,
# but I don't feel comfortable masking error warnings.

str(clinic_data[, ratios], list.len = length(clinic_data[, ratios]))

```

I am not sure about why all those `NAs introduced by coercion` appear. I suspect it is because `NA` values in the table are stored as text.


## Variables: type and description

I might have allowed myself to get carried along in passion choosing a file too big. The table contains 165 variables. It is not a ridiculous number, but may be not easy enough to handle for the scope of this study.

```{r}
str(clinic_data, list.len = length(clinic_data))
```

From those 165 variables, 17 are character strings, 25 are integers and 123 are non-integer numbers.



Las variables de texto corresponden a datos descriptivos como: nombre de la clínica, ciudad en la que se ubica, estado, nombre del director médico y si dispone o no de una serie de servicios (donación de óvulos, donación de embriones, programa de criopreservación de óvulos, programa de criopreservación de embriones, si atienden a mujeres solteras, servicio de maternidad subrogada, si la clínica es miembro de la SART (Society for Assisted Reproductive Technology) y si dispone de un laboratorio de embriología acreditado). Muchas de estas variables funcionarán como factores.

Las variables de tipo `entero` son:
*OrderID*: identificador único de cada registro.  
*ND_NumIntentRet*: número de intentos de recogida de óvulos (excluyendo donantes). Como ocurrirá con la mayoría de variables numéricas, está dividida en cinco categorías de edad, desde menores de 35 años hasta mayores de 43.  
*ND_NumRetrieve*: número de recogida de óvulos (excluyendo donantes). No coincide con el número de intentos porque, en ocasiones, es necesario detener el proceso de recogida o este no tiene éxito.  
*ND_NumTrans*: número de transferencias (excluyendo donantes). Transferencia es la técnica por la que un embrión creado in vitro es transferido del medio de cultivo al útero de la paciente.  
*Donor_NumTrans*: Número de transferencias a partir de ovocitos de donante. Esta categoría está dividida en cuatro variables según si los ovocitos son frescos o congelados, si el embrión ha sido congelado o no y si el embrión es una donación.  
*TotNumCycles*: Número total de ciclos. En reproducción asistida los ciclos incluyen cualquier proceso en el que se dé al menos una de estas situaciones; 1) se lleva a cabo un procedimiento de reproducción asistida, 2) la paciente se ha sometido a estimulación ovárica o vigilancia ovárica con intención de llevar a cabo un procedimiento de reproducción asistida, o 3) se han descongelado embriones con intención de transferirlos a una paciente.  
*NumResearch*: Número de ciclos de investigación excluidos.  

Las variables de tipo numérico son:
*ND_IntentRetLB*: Porcentaje de intentos de recogida de óvulos que han resultado en nacido vivo (excluyendo donantes).  
*ND_IntentRetSingleLB*: Porcentaje de intentos de recogida de óvulos que han resultado en un único nacido vivo (excluyendo donantes).  
*ND_RetrieveLB*: Porcentaje de recogida de ovocitos que han resultado en nacido vivo (excluyendo donantes).  
*ND_RetrieveSingleLB*: Porcentaje de recogida de ovocitos que han resultado en un único nacido vivo (excluyendo donantes).  
*ND_TransLB*: Porcentaje de transferencias que dan como resultado nacidos vivos (excluyendo donantes).  
*ND_TransSingleLB*: Porcentaje de transferencias que dan como resultado un único nacido vivo (excluyendo donantes).  
*ND_IntentRetPerLB*: Número de intentos de recogida por cada nacimiento de vivos (excluyendo donantes).  
*NewND_1IntentRetLB1*: Porcentaje de nuevos pacientes con nacidos vivos tras un único intento de recogida (excluyendo donantes).  
*NewND_2IntentRetLB*: Porcentaje de nuevos pacientes con nacidos vivos tras uno o dos intentos de recogida (excluyendo donantes).  
*NewND_AllIntentRetLB*: Porcentaje de nuevos pacientes con nacidos vivos tras todos los intentos de recogida (excluyendo donantes).  
*NewND_IntentRetPerNew1*: Número mmedio de intentos de recogida de ovocitos por cada nuevo paciente (excluyendo donantes).  
*NewND_TransPerIntentRet1*: Número medio de transferencias por intento de recogida (excluyendo donantes).  
*Donor_TransLB*: Porcentaje de transferencias resultando en nacidos vivos (sólo donantes). Esta variable está dividida en cuatro según si la transferencia se ha hecho a partir de ovocito fresco, congelado, embrión congelado o embrión donado.  
*Donor_TranSingleLB*: Porcentaje de transferencias restultando en un único nacido vivo (sólo donaciones). Dividido en cuatro variables según el punto de partida sean ovocitos frescos, congelados, embriones congelados o embriones donados.  
*CycleCancel*: Porcentaje de ciclos cancelados antes de la recogida o la descongelación.  
*CycleStop*: Porcentaje de ciclos detenidos entre la recogida y la transferencia (o almacenamiento en banco).  
*CycleFertPres*: Porcentaje de ciclos dedicados a preservación de fertilidad.  
*TransCarrier*: Porcentaje de transferencias con uso de gestación subrogada.  
*TransFrozEmb*: Porcentaje de transferencias usando embriones congelados.  
*TransICSI*: Porcentaje de transferencias en las que al menos un embrión procede de ICSI.  
*TransPGT*: Porcentaje de transferencias en las que al menos un embrión se ha sometido a DGP.  
*ReasonMale*: Porcentaje de ciclos debidos a factor masculino.  
*ReasonEndo*: Porcentaje de ciclos debidos a endometriosis.  
*ReasonTubal*: Porcentaje de ciclos debidos a problemas en las trompas de Falopio.  
*ReasonOvul*: Porcentaje de ciclos debidos a disfunción ovulatoria.  
*ReasonUterine*: Porcentaje de ciclos debidos a problemas uterinos.  
*ReasonPGT*: Porcentaje de ciclos debidos a DGP.  
*ReasonCarrier*: Porcentaje de ciclos debidos a gestación subrogada.  
*ReasonDOR*: Porcentaje de ciclos por reserva ovárica disminuida.  
*ReasonBank*: Porcentaje de ciclos para adición a banco.  
*ReasonPregLoss*: Porcentaje de ciclos por pérdida recurrente de embarazo.  
*ReasonOtherInfert*: Porcentaje de ciclos por otras razones de infertilidad.  
*ReasonNonInfert*: Porcentaje de ciclos por otras razones, no relacionadas con la infertilidad.  
*ReasonUnexplained*: Porcentaje de ciclos por razones indeterminadas.  


# 3. Preguntas objetivo

Resumen numérico básico del número total de ciclos por hospital (sin tener en cuenta la edad de la paciente):
```{r}
# Resumen numérico básico
estadisticos <- c("media", "min.", "max.", "desv.estandar", "C.V.", "25%", "50%", "75%")
variables <- c("TotNumCyclesAll")
df <- clinic_data
est_vector <- c()

for (var in variables) {
  df_subset <- df[,var] # Extraigo la columna de valores correspondiente a la variable
  var_sd <- sd(df_subset, na.rm=TRUE) # desviación estándar
  var_mean <- mean(df_subset, na.rm = TRUE) # media
  var_min <- min(df_subset,na.rm = TRUE)
  var_max <- max(df_subset, na.rm = TRUE)
  var_CV <- var_sd/var_mean # coeficiente de variación
  var_percentile <- quantile(df_subset, probs=c(0.25, 0.5, 0.75), names=FALSE, na.rm = TRUE) # percentiles
  est_vector = c(est_vector, var_mean, var_min, var_max, var_sd, var_CV, var_percentile) # Voy añadiendo todos los resultados a un mismo vector.
  }

# Convierto el vector con todos los resultados en una matriz, y esta en una dataframe.
testmatrix <- matrix(data=est_vector, ncol=length(estadisticos), byrow = TRUE, 
                     dimnames = list(variables, estadisticos))
testdf <- as.data.frame(testmatrix)

testdf
```

Histograma de frecuencia mostrando número de transferencias procedentes de donante. Cuatro gráficas represenando el punto de partida: ovocito fresco, congelado, embrión congelado y embrión donado (en los otros tres casos la donación es el ovocito, no el embrión).

```{r}
par(mfrow = c(2, 2)) # generamos un array de 2x2 para dibujar las gráficas.

xlab <- "Transferencias por hospital"
ylab <- "Frecuencia"

hist(clinic_data$Donor_NumTrans1,
     main = "Embrión fresco de ovocito fresco", xlab = xlab, ylab = ylab, col = "blue")
hist(clinic_data$Donor_NumTrans2,
     main = "Embrión fresco de ovocito congelado", xlab = xlab, ylab = ylab, col = "tomato")
hist(clinic_data$Donor_NumTrans3,
     main = "Embrión congelado", xlab = xlab, ylab = ylab, col = "yellow")
hist(clinic_data$Donor_NumTrans4,
     main = "Embrión donado", xlab = xlab, ylab = ylab, col = "green")


```

Uno de los datos que se nos ofrece es el estado de la acreditación del laboratorio de embriología. Para este tipo de datos puede ser más útil una tabla que una gráfica:


```{r}
table(clinic_data$LabAccred)
```

En cambio sí que nos puede resultar más interesante ver en una gráfica otro tipo de datos cualitativos. Por ejemplo, cuántas clínicas que ofrecen servicio de reproducción asistida hay en cada estado.

```{r}
# Most of this code I adapted it from:
# https://stackoverflow.com/questions/10286473/rotating-x-axis-labels-in-r-for-barplot

par(mar = c(7, 4, 2, 2) + 0.2)

end_point <- 0.5 + length(unique(clinic_data$CurrentClinicState)) + length(unique(clinic_data$CurrentClinicState))-1

barplot(sort(table(clinic_data$CurrentClinicState), decreasing = TRUE),
        # This adjust the maxim value in the y axis:
        ylim = c(0,5+max(table(clinic_data$CurrentClinicState))),
        xaxt = "n", # Avoids plotting the names in the x axis.
        space = 1)

text(seq(1.5,end_point,by=2), par("usr")[3]-0.25, 
     srt = 60, adj= 1, xpd = TRUE,
     labels = paste(unique(clinic_data$CurrentClinicState)), cex=0.55)
```

Does the number of intended retrievals change with age? Let's use a boxplot graphic:

```{r}
# To avoid problems with the logarithm of 0, let's change the value 0 by value 1.
intended_retrievals <- clinic_data[,7:11]
intended_retrievals[intended_retrievals == 0] <- 1

boxplot(intended_retrievals,
        log = "y",
        yaxt = "n",  # No dibuja los ticks del eje y.
        xlab = "Age groups",
        ylab = "Intended Retrievals by Clinic",
        main = "Intended Retrievals by Clinic and Age Group",
        names = c("<35", "35-37", "38-40", "41-42", ">=43"))

# establece los límites del eje y a partir del logaritmo en base 10
# de los valores máximos y mínimos del dataframe.
y1 <- floor(log10(range(intended_retrievals))) 
# Vector con los valores enteros desde el mínimo al máximo del eje.
pow <- seq(y1[1], y1[2]+1)
# Vector con las posiciones de los ticks.
ticksat <- as.vector(sapply(pow, function(p) (1:10)*10^p))
# Drawing the axis (main ticks)
axis(2, 10^pow)
# Drawing the axis (secondary ticks)
axis(2, ticksat, labels = NA, tcl = -0.25, lwd = 0, lwd.ticks = 1)
```

I suspect that the median diminishes with age group because donor eggs are prefered for older women instead of retrieval of their own eggs.

De la misma forma, nos podemos preguntar qué porcentaje de intentos de recogida de ovocitos da lugar a nacidos vivos. Eso nos orientaría un poco en la pregunta de si vale la pena recoger ovocitos de las pacientes cuando son de edad relativamente avanzada.

```{r}
# To avoid problems with the logarithm of 0, let's change the value 0 by value 1.
pct_int_ret <- clinic_data[,12:16]
# pct_int_ret[pct_int_ret == 0] <- 1

boxplot(pct_int_ret,
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of intended retrievals resulting in live births \nby hospital and age group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"))

```

Como sospechábamos, este gráfico muestra un descenso muy acusado en el ratio de intentos de recogida de ovocitos resultantes en nacidos vivos si tenemos en cuenta el grupo de edad de la madre.

# 4. Análisis descriptivo

En esta sección llevaremos a cabo una exploración más exhaustiva de nuestras variables, incluyendo un resumen paramétrico de los datos y representaciones gráficas.

## Servicios

Un sumario de los servicios ofrecidos por las clínicas.

```{r}
# Columnas que contienen los datos de los servicios: 155-160 y 162
services <- clinic_data[c(155:160, 162)]

# nombres de variables:
services_names <- c("Donación de ovocitos",
  "Donación de embriones",
  "Criopreservación de embriones",
  "Criopreservación de ovocitos",
  "Atención a mujeres solteras",
  "Gestación subrogada",
  "Laboratorio de embriología")

colnames(services) <- services_names

lapply(services, table)

```

## Resultados de las técnicas de reproduccion

Resumen descriptivo de las variables numéricas:

```{r}

variables <- colnames(clinic_data[c(7:154, 163)])
estadisticos <- c("media", "min.", "max.", "desv.estandar", "C.V.", "25%", "50%", "75%")
est_vector <- c()

for (var in variables) {
    df_subset <- clinic_data[,var] # Extraigo la columna de valores correspondiente a la variable
    var_sd <- sd(df_subset, na.rm=TRUE) # desviación estándar
    var_mean <- mean(df_subset, na.rm = TRUE) # media
    var_min <- min(df_subset,na.rm = TRUE)
    var_max <- max(df_subset, na.rm = TRUE)
    var_CV <- var_sd/var_mean # coeficiente de variación
    var_percentile <- quantile(df_subset, probs=c(0.25, 0.5, 0.75), names=FALSE, na.rm = TRUE) # percentiles
    est_vector = c(est_vector, var_mean, var_min, var_max, var_sd, var_CV, var_percentile) # Voy añadiendo todos los resultados a un mismo vector.
  }
  
  # Convierto el vector con todos los resultados en una matriz, y esta en una dataframe.
  testmatrix <- matrix(data=est_vector, ncol=length(estadisticos), byrow = TRUE, 
                       dimnames = list(variables, estadisticos))
  testdf <- as.data.frame(testmatrix)
  
  testdf

```

## Representaciones gráficas

### Retrievals

**Egg retrieval** is a procedure to collect the eggs contained in the ovarian follicles.

```{r}
# Since I think I am going to need this code several times, I will wrap it into a function.

log_boxplot <- function(x, ...){
  # To avoid problems with the logarithm of 0, let's change the value 0 by value 1.
  x[x == 0] <- 1

  boxplot(x,
        log = "y",
        yaxt = "n",  # No dibuja los ticks del eje y.
        ...) # Additional arguments to be passed to the function boxplot.

# establece los límites del eje y a partir del logaritmo en base 10
# de los valores máximos y mínimos del dataframe.
  y1 <- floor(log10(range(x))) 
# Vector con los valores enteros desde el mínimo al máximo del eje.
  pow <- seq(y1[1], y1[2]+1)
# Vector con las posiciones de los ticks.
  ticksat <- as.vector(sapply(pow, function(p) (1:10)*10^p))
# Drawing the axis (main ticks)
  axis(2, 10^pow)
# Drawing the axis (secondary ticks)
  axis(2, ticksat, labels = NA, tcl = -0.25, lwd = 0, lwd.ticks = 1)
}
```

```{r fig.height = 15, fig.width = 8}
# Let's actually draw the graphs.

par(mfcol = c(3, 1))

# Egg retrievals by clinic
x <- clinic_data[,22:26]
log_boxplot(x,xlab = "Age groups", ylab = "Egg Retrievals by Clinic",
        main = "Egg Retrievals by Clinic and Age Group",
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "aliceblue")

# Ratio of retrievals resulting in live births
boxplot(clinic_data[c(27:31)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Retrievals Resulting in Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "lightgoldenrod1")

# Ratio of retrievals resulting in singleton live births
boxplot(clinic_data[c(32:36)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Retrievals Resulting in Singleton Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "coral")
```

I have had some problems with this image. Labels and points are more little than I wanted, but at least I have managed to include all three graphs into the same image.


## Transfers

**Transfer** is a procedure in which an embryo is transferred, from laboratory culture, to the uterus.

Live above, we will represent number of transfers, percentage of transfers resulting in live births, and those resulting in singleton live births.

```{r fig.height = 15, fig.width = 8}

par(mfcol = c(3, 1))

# Number of transfers
x <- clinic_data[,37:41]
log_boxplot(x,xlab = "Age groups", ylab = "Transfers by Clinic",
        main = "Number of Transfers by Clinic and Age Group",
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "aliceblue")

# Ratio of transfers resulting in live births
boxplot(clinic_data[c(42:46)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Transfers Resulting in Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "lightgoldenrod1")

# Ratio of transfers resulting in singleton live births
boxplot(clinic_data[c(47:51)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Transfers Resulting in Singleton Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "coral")
```

Look at the median value of the percentage of transfers resulting in live births for the >=43 years age group. It is zero. If we look up the value of the mean, it is a just bit better with 0.11.

All in all, even the median ratio for the youngest age group is not that great, a tad under 0.5 (0.48).