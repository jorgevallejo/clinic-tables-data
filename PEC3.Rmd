---
title: "2017 Clinic Dataset Analysis"
subtitle: "Assisted reproduction clinics data from the CDC"
author: "Jorge Vallejo Ortega"
output:
  md_document: default
  pdf_document: default
---
# Foreword
This work is inspired in an exercise from the course 'Software para el análisis de datos' in UOC's degree 'Bioinformática y Bioestadística'.

I am using this to learn the use of the language R, and the tools RStudio, Git and GitHub. This is not a professional level study of assisted reproduction data from clinics in the USA. If you want to have access to such studies, or even the raw data, you can get them from CDC's webpage [ART's Success Rate Data](https://www.cdc.gov/art/artdata/index.html).


## Statement
MARKDOWN will be used for this paper, generating a Pdf report with Knitr in RStudio.

The file with the R code have to be delivered as well.

From a dataset, a statistical study must be carried out using R. The points below can be used as an outline:

### 1. Look for a dataset related with Biostatistics or Bioinformatics.
Must be public data.
Explain source of data and include pertinent references. Justify why that specific dataset has been chosen.

### 2. Display the data.
Using R, display and explain the type of file that has been imported, which variables are included (type, classification,...) and anything else that seems relevant.  
Include snapshots and R commands used for import and display of the data.


### 3. Probe questions.
Make a minimum of six questions that probe the kind of information contained in the dataset.


### 4. Descriptive analysis of the data.
The paper must include a parametric summary of the data and several graphic representations of said data.


### 5. Probability and simulation.
A minimum of three questions answering probability questions and a question corresponding a short simulation model.


### 6. Regression analysis.
A brief regression analysis from the variables in the dataset answering some question of interest.


### 7. Final assessment.
Final assessment from source data and papaer:
Do we have conclussions?
Would be necessary a more advanced analysis?
Would be necessary more data for obtaining another kind of information?


 
# 1. Dataset

I wanted to do something with data from human assisted reproduction techniques. Those are difficult to find as public datasets, I suppose that it is due to privacy issues.

Finally, I found public datasets published by the Centers for Disease Control and Prevention (CDC) with several kinds of data from assisted reproduction clinics in the United States:  
https://www.cdc.gov/art/artdata/index.html

Other datasets from previous years can be downloaded/looked up as well:  
https://www.cdc.gov/art/reports/archive.html


# Datasets downloading

```{r eval = FALSE}

# The code option eval = FALSE prevents this chunk to run. In this way, data WON'T
# be downloaded each time the .Rmd file is knitted to produce a report.
# For allowing this chunk to run, change eval to TRUE.

source_url <- "https://www.cdc.gov/art/artdata/docs/excel/FINAL-2017-Clinic-Table-Dataset.xlsx"

download.file(source_url, destfile = "../datos/FINAL-2017-Clinic-Table-Dataset.xlsx", method = "curl")
```

This is the dataset I am using for this practise study, but we could want to download datasets from previous years to do longitudinal studies:

```{r eval = FALSE}

# The code option eval = FALSE prevents this chunk to run. In this way, data WON'T
# be downloaded each time the .Rmd file is knitted to produce a report.
# For allowing this chunk to run, change eval to TRUE.

years <- c(1995:2015)

url_start1 <- "https://www.cdc.gov/art/excelfiles/clinic_tables_data_"
url_start2 <- "https://www.cdc.gov/art/excelfiles/"
url_start3 <- "https://www.cdc.gov/art/artdata/docs/excel/FINAL-"

file_start1 <- "clinic_tables_data_"
file_start2 <- ""
file_start3 <- "FINAL-"

url_end1 <- ".xls"
url_end2 <- "-clinic-tables-dataset.xls"
url_end3 <- "-clinic-table-dataset.xls"

# This code is rough on the edges, it doesn't take into account when a file
# fails to download.

for (year in years){
  if (year <= 2012){
    url <- paste0(url_start1, year, url_end1)
    destfile <- paste0(file_start1, year, url_end1)
  }
  else if (year == 2013){
    url <- paste0(url_start2, year, url_end2)
    destfile <- paste0(file_start2, year, url_end2)
  }
    else if (year == 2014){
    url <- "https://www.cdc.gov/art/artdata/docs/excel/2014-Clinic-Tables-Data-Dictionary.xls"
    destfile <- "2014-Clinic-Tables-Data-Dictionary.xls"
  }
  else {
    url <- paste0(url_start3, year, url_end3)
    destfile <- paste0(file_start3, year, url_end3)
  }
  
  #cat(url, "\n", destfile, "\n\n") # Cheks that the names of url and files are rightly constructed.
  download.file(url, destfile, method = "curl")
}
```


# 2. Display data

The downloaded file _FINAL-2017-Clinic-Table-Dataset.xlsx_ includes data from assisted reproduction treatments from 448 US clinics, collected during 2017. It is an Excel workbook containing four sheets:

**National Summary Data**. Aggregated data from all the clinics included in the report.  
**National Table Dictionary**. Dictionary-table with the explanation for each variable in the previous table.  
**Clinic Table Data Records**. Tabla with data broke down by clinic.  
**Clinic Table Dictionary**.  Dictionary-table explaining each variable from Clinic Table.  

I am interested in the data broke down by clinic. Therefore, I will import the data from sheets **Clinic Table Dictionary** and **Clinic Table Data Records**.

```{r}
require("xlsx")
clinic_dictionary <- read.xlsx("../datos/FINAL-2017-Clinic-Table-Dataset.xlsx", 4,
                               endRow = 165, encoding = "UTF-8")
# Everything is NA after row 166; row 166 is a comment.

View(clinic_dictionary)

# In Viewer, in the column Age the symbols '>=' are displayed as '=',
# but if we print the column to screen the correct symbols are displayed.

clinic_data <- read.xlsx("../datos/FINAL-2017-Clinic-Table-Dataset.xlsx", 3
                         , encoding = "UTF-8", stringsAsFactors=FALSE)
View(clinic_data)

```

Let's see how each variable has been codified:

```{r}
str(clinic_data, list.len = length(clinic_data))
```


In the structure can be seen a problem from this data source. Percentages and ratios are
coded as text, not as numbers. It will be necessary pre-process the data from the table before we can work with them.

Why numeric variables are detected  as characters. Ratios contain non-numeric symbols ("%", "/", "<"). What's the problem with the rest?

We will order alphabetically each column, see what happens.

First of all, to avoid problems down the line, we will change null values in the table for `NA`:

```{r}
clinic_data[clinic_data==""] <- NA

View(clinic_data)
```

Should we order the values in the columns, we see that there are columns with integers in which the thousands are marked with a comma (`,`).

```{r}
ordenadas <- sapply(clinic_data, function(x) sort(x, na.last = TRUE))

View(ordenadas)

```

Next, we will correct those variables that should be `integer` o `numeric`.

Code adapted from a question in Stack Overflow:
[How to read data when some numbers contain commas as thousand separator?](https://stackoverflow.com/questions/1523126/how-to-read-data-when-some-numbers-contain-commas-as-thousand-separator)

```{r}
# Vectors that refer the columns that should be integers
# and the columns that should be ratios.

integers <- c(7:11, 22:26, 37:41, 82:85, 94:99, 163)
ratios <- c(12:21, 27:36, 42:81, 86:93, 100:154)

# Pre-processing columns with integers deleting "," symbol.
clinic_data[, integers] <- lapply(clinic_data[, integers],
                                  function(x){
                                    as.integer(gsub(",", "", x))
                                  })

str(clinic_data[, integers])
```

Pre-processing the columns with rations is a bit more complex. It is necessary to deal with three different cases:

1) Data as <1%. Since we don't have the real value, what I will do is arbitrarily chose
the value 0.5%, expressed as 0.005 ratio.

2) Data including "%" symbol. Same strategy that we followed with integers;
I will remove the symbol with `gsub`. Besides, I will divide the result by 100, making all numbers a ratio (parts per unit).

3) Data as fractions. Even a bit more complex. I will use regular expressions to isolate numerator and denominator, and will return the result of the division as a ratio.

```{r}
# This function process ratios expressed as fractions.
divide <- function(x){
  numerator <- as.numeric(gsub(" .*$", "", x))
  denominator <- as.numeric(gsub("^.*/ ", "", x))
  return (numerator / denominator)
}

# This is the main functios for processing ratios from characters to numbers.
# Expect the appearance of several warnings of 'NA introduced by coercion' due to multiple # data points represented as 'NA' in characters which the function is unable to deal with.
numerizador <- function(dato){
    ifelse (dato == "<1%", 0.005,
            ifelse ((grepl("%", dato) == TRUE), as.numeric(gsub("%", "", dato))/100,
                    ifelse ((grepl("/", dato)==TRUE), divide(dato), as.numeric(dato))))
}
# The function 'ifelse' is needed for working with vectors of length >1.

# Pre-processing ratios:
clinic_data[, ratios] <- lapply(clinic_data[, ratios], numerizador)
# When using this expression, multiple warnings of 'NAs introduced by coercion' appear.
# I think it is due to "NA" being stored as character strings.
# I haven't been able to correct it yet. It is possible to avoid the raise of the warning,
# but I don't feel comfortable masking error warnings.

str(clinic_data[, ratios], list.len = length(clinic_data[, ratios]))

```

I am not sure about why all those `NAs introduced by coercion` appear. I suspect it is because `NA` values in the table are stored as text.


## Variables: type and description

I might have allowed myself to get carried along in passion choosing a file too big. The table contains 165 variables. It is not a ridiculous number, but may be not easy enough to handle for the scope of this study.

```{r}
str(clinic_data, list.len = length(clinic_data))
```

From those 165 variables, 17 are character strings, 25 are integers and 123 are non-integer numbers.

Character variables correspond to descriptive data as: clinic name, city of the clinic, state, name of the medical director, and the disponibility of several services(oocyte donation, embryo donation, oocyte cryopreservation, embryo cryopreservation, services for single women, gestational carriers, if the clinic is a member of SART (Society for Assisted Reproductive Technology), and if the clinic owns an accredited embryology laboratory). Many of these variables will work as factors.

Variables of type `integer`are:
*OrderID*: unique identifier for each register.  
*ND_NumIntentRet*: number of intended oocyte retrievals (excluyendo donors). As in most of numerical variables in this table, this one is divided into five age categories, from less than 35 years old to more than 43 years old.  
*ND_NumRetrieve*: number of oocyte retrievals (excluding donors). It doesn't match with intended retrievals because, sometimes, it is necessary to stop the retrieval process or a particular process is not successful.  
*ND_NumTrans*: number of transfers (excluding donors). Transfer is the technique by with an embryo gronw in vitro is transferred from cultured to the patient uterus.  
*Donor_NumTrans*: number of transfers from donor oocytes. This category is divided into four variables depending if the oocytes are fresh of frozen, fresh or frozen embryo, and embryo from donor.  
*TotNumCycles*: total number of cycles. In assisted reproduction, the cycles include any process in which at least one of this conditions happen; 1) an assisted reproduction process is carried out, 2) the patient is subjected to ovarian stimulation or monitoring with the intent of having an ART procedure, or 3) frozen embryos have been thawed with the intent of transferring them to a patient.  
*NumResearch*: number of excluded cycles for research.  

Numeric variables are:
*ND_IntentRetLB*: Percentage of intended oocyte retrievals resulting in live births (exluding donors).  
*ND_IntentRetSingleLB*: Percentage of intended oocyte retrievals resulting in singleton live births (excluding donors).  
*ND_RetrieveLB*: Percentage of oocyte retrievals resulting in live births (excluding donors).  
*ND_RetrieveSingleLB*: Percentage of oocyte retrievals resulting in singleton live births (excluding donors).  
*ND_TransLB*: Percentage of transfers resulting in live births (excluding donors).  
*ND_TransSingleLB*: Percentage of transfers resulting in singleton live births (excluding donors).  
*ND_IntentRetPerLB*: Number of intended oocyte retrievals resulting in live births (excluding donors).  
*NewND_1IntentRetLB1*: Percentage of new patients with live birth after one intended retrieval (excluding donors).  
*NewND_2IntentRetLB*: Percentage of new patients with live birth after one or two intended retrievals (excluding donors).  
*NewND_AllIntentRetLB*: Percentage of new patients with live birth after all intended retrievals (excluding donors).  
*NewND_IntentRetPerNew1*: Average number of intended retrievals per new patient (excluding donors).  
*NewND_TransPerIntentRet1*: Average number of transfers per intended retrieval (excluding donors).  
*Donor_TransLB*: Percentage of transfers resulting in live births (only donors). This variable is divided in four variables according to the condition of the oocyte (fresh, frozen, frozen embryo, embryo from donor).  
*Donor_TranSingleLB*: Percentage of transfers resulting in a singleton live birth (only donors). Divided in four variables according to the condition of the oocyte (fresh, frozen, frozen embryo, embryo from donor).  
*CycleCancel*: Percentage of cycles canceled prior to retrieval or thawing.  
*CycleStop*: Percentage of cycles canceled between retrieval and transfer or banking.  
*CycleFertPres*: Percentage of cycles for fertility preservation.  
*TransCarrier*: Percentage of transfers using gestational carrier.  
*TransFrozEmb*: Percentage of transfers using frozen embryos.  
*TransICSI*: Percentage of transfers of at least one embryo with ICSI.  
*TransPGT*: Percentage of transfers of at least on embryo with PGT.  
*ReasonMale*: Percentage of cycles for male factor reason.  
*ReasonEndo*: Percentage of cycles for endometriosis reason.  
*ReasonTubal*: Percentage of cycles for tubal factor reason.  
*ReasonOvul*: Percentage of cycles for ovulatory disfunction reason.  
*ReasonUterine*: Percentage of cycles for uterine factor reason.  
*ReasonPGT*: Percentage of cycles for PGT reason.  
*ReasonCarrier*: Percentage of cycles for gestational carrier reason.  
*ReasonDOR*: Percentage of cycles for diminished ovarian reserve reason.  
*ReasonBank*: Percentage of cycles for banking reason.  
*ReasonPregLoss*: Percentage of cycles for recurrent pregnancy loss reason.  
*ReasonOtherInfert*: Percentage of cycles for other infertility reason.  
*ReasonNonInfert*: Percentage of cycles for other non-infertility reason.  
*ReasonUnexplained*: Percentage of cycles for unexplained reason.  


# 3. Probe questions

Resumen numérico básico del número total de ciclos por hospital (sin tener en cuenta la edad de la paciente):
```{r}
# Resumen numérico básico
estadisticos <- c("media", "min.", "max.", "desv.estandar", "C.V.", "25%", "50%", "75%")
variables <- c("TotNumCyclesAll")
df <- clinic_data
est_vector <- c()

for (var in variables) {
  df_subset <- df[,var] # Extraigo la columna de valores correspondiente a la variable
  var_sd <- sd(df_subset, na.rm=TRUE) # desviación estándar
  var_mean <- mean(df_subset, na.rm = TRUE) # media
  var_min <- min(df_subset,na.rm = TRUE)
  var_max <- max(df_subset, na.rm = TRUE)
  var_CV <- var_sd/var_mean # coeficiente de variación
  var_percentile <- quantile(df_subset, probs=c(0.25, 0.5, 0.75), names=FALSE, na.rm = TRUE) # percentiles
  est_vector = c(est_vector, var_mean, var_min, var_max, var_sd, var_CV, var_percentile) # Voy añadiendo todos los resultados a un mismo vector.
  }

# Convierto el vector con todos los resultados en una matriz, y esta en una dataframe.
testmatrix <- matrix(data=est_vector, ncol=length(estadisticos), byrow = TRUE, 
                     dimnames = list(variables, estadisticos))
testdf <- as.data.frame(testmatrix)

testdf
```

Histograma de frecuencia mostrando número de transferencias procedentes de donante. Cuatro gráficas represenando el punto de partida: ovocito fresco, congelado, embrión congelado y embrión donado (en los otros tres casos la donación es el ovocito, no el embrión).

```{r}
par(mfrow = c(2, 2)) # generamos un array de 2x2 para dibujar las gráficas.

xlab <- "Transferencias por hospital"
ylab <- "Frecuencia"

hist(clinic_data$Donor_NumTrans1,
     main = "Embrión fresco de ovocito fresco", xlab = xlab, ylab = ylab, col = "blue")
hist(clinic_data$Donor_NumTrans2,
     main = "Embrión fresco de ovocito congelado", xlab = xlab, ylab = ylab, col = "tomato")
hist(clinic_data$Donor_NumTrans3,
     main = "Embrión congelado", xlab = xlab, ylab = ylab, col = "yellow")
hist(clinic_data$Donor_NumTrans4,
     main = "Embrión donado", xlab = xlab, ylab = ylab, col = "green")


```

Uno de los datos que se nos ofrece es el estado de la acreditación del laboratorio de embriología. Para este tipo de datos puede ser más útil una tabla que una gráfica:


```{r}
table(clinic_data$LabAccred)
```

En cambio sí que nos puede resultar más interesante ver en una gráfica otro tipo de datos cualitativos. Por ejemplo, cuántas clínicas que ofrecen servicio de reproducción asistida hay en cada estado.

```{r}
# Most of this code I adapted it from:
# https://stackoverflow.com/questions/10286473/rotating-x-axis-labels-in-r-for-barplot

par(mar = c(7, 4, 2, 2) + 0.2)

end_point <- 0.5 + length(unique(clinic_data$CurrentClinicState)) + length(unique(clinic_data$CurrentClinicState))-1

barplot(sort(table(clinic_data$CurrentClinicState), decreasing = TRUE),
        # This adjust the maxim value in the y axis:
        ylim = c(0,5+max(table(clinic_data$CurrentClinicState))),
        xaxt = "n", # Avoids plotting the names in the x axis.
        space = 1)

text(seq(1.5,end_point,by=2), par("usr")[3]-0.25, 
     srt = 60, adj= 1, xpd = TRUE,
     labels = paste(unique(clinic_data$CurrentClinicState)), cex=0.55)
```

Does the number of intended retrievals change with age? Let's use a boxplot graphic:

```{r}
# To avoid problems with the logarithm of 0, let's change the value 0 by value 1.
intended_retrievals <- clinic_data[,7:11]
intended_retrievals[intended_retrievals == 0] <- 1

boxplot(intended_retrievals,
        log = "y",
        yaxt = "n",  # No dibuja los ticks del eje y.
        xlab = "Age groups",
        ylab = "Intended Retrievals by Clinic",
        main = "Intended Retrievals by Clinic and Age Group",
        names = c("<35", "35-37", "38-40", "41-42", ">=43"))

# establece los límites del eje y a partir del logaritmo en base 10
# de los valores máximos y mínimos del dataframe.
y1 <- floor(log10(range(intended_retrievals))) 
# Vector con los valores enteros desde el mínimo al máximo del eje.
pow <- seq(y1[1], y1[2]+1)
# Vector con las posiciones de los ticks.
ticksat <- as.vector(sapply(pow, function(p) (1:10)*10^p))
# Drawing the axis (main ticks)
axis(2, 10^pow)
# Drawing the axis (secondary ticks)
axis(2, ticksat, labels = NA, tcl = -0.25, lwd = 0, lwd.ticks = 1)
```

I suspect that the median diminishes with age group because donor eggs are prefered for older women instead of retrieval of their own eggs.

De la misma forma, nos podemos preguntar qué porcentaje de intentos de recogida de ovocitos da lugar a nacidos vivos. Eso nos orientaría un poco en la pregunta de si vale la pena recoger ovocitos de las pacientes cuando son de edad relativamente avanzada.

```{r}
# To avoid problems with the logarithm of 0, let's change the value 0 by value 1.
pct_int_ret <- clinic_data[,12:16]
# pct_int_ret[pct_int_ret == 0] <- 1

boxplot(pct_int_ret,
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of intended retrievals resulting in live births \nby hospital and age group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"))

```

Como sospechábamos, este gráfico muestra un descenso muy acusado en el ratio de intentos de recogida de ovocitos resultantes en nacidos vivos si tenemos en cuenta el grupo de edad de la madre.

# 4. Análisis descriptivo

En esta sección llevaremos a cabo una exploración más exhaustiva de nuestras variables, incluyendo un resumen paramétrico de los datos y representaciones gráficas.

## Servicios

Un sumario de los servicios ofrecidos por las clínicas.

```{r}
# Columnas que contienen los datos de los servicios: 155-160 y 162
services <- clinic_data[c(155:160, 162)]

# nombres de variables:
services_names <- c("Donación de ovocitos",
  "Donación de embriones",
  "Criopreservación de embriones",
  "Criopreservación de ovocitos",
  "Atención a mujeres solteras",
  "Gestación subrogada",
  "Laboratorio de embriología")

colnames(services) <- services_names

lapply(services, table)

```

## Resultados de las técnicas de reproduccion

Resumen descriptivo de las variables numéricas:

```{r}

variables <- colnames(clinic_data[c(7:154, 163)])
estadisticos <- c("media", "min.", "max.", "desv.estandar", "C.V.", "25%", "50%", "75%")
est_vector <- c()

for (var in variables) {
    df_subset <- clinic_data[,var] # Extraigo la columna de valores correspondiente a la variable
    var_sd <- sd(df_subset, na.rm=TRUE) # desviación estándar
    var_mean <- mean(df_subset, na.rm = TRUE) # media
    var_min <- min(df_subset,na.rm = TRUE)
    var_max <- max(df_subset, na.rm = TRUE)
    var_CV <- var_sd/var_mean # coeficiente de variación
    var_percentile <- quantile(df_subset, probs=c(0.25, 0.5, 0.75), names=FALSE, na.rm = TRUE) # percentiles
    est_vector = c(est_vector, var_mean, var_min, var_max, var_sd, var_CV, var_percentile) # Voy añadiendo todos los resultados a un mismo vector.
  }
  
  # Convierto el vector con todos los resultados en una matriz, y esta en una dataframe.
  testmatrix <- matrix(data=est_vector, ncol=length(estadisticos), byrow = TRUE, 
                       dimnames = list(variables, estadisticos))
  testdf <- as.data.frame(testmatrix)
  
  testdf

```

## Representaciones gráficas

### Retrievals

**Egg retrieval** is a procedure to collect the eggs contained in the ovarian follicles.

```{r}
# Since I think I am going to need this code several times, I will wrap it into a function.

log_boxplot <- function(x, ...){
  # To avoid problems with the logarithm of 0, let's change the value 0 by value 1.
  x[x == 0] <- 1

  boxplot(x,
        log = "y",
        yaxt = "n",  # No dibuja los ticks del eje y.
        ...) # Additional arguments to be passed to the function boxplot.

# establece los límites del eje y a partir del logaritmo en base 10
# de los valores máximos y mínimos del dataframe.
  y1 <- floor(log10(range(x))) 
# Vector con los valores enteros desde el mínimo al máximo del eje.
  pow <- seq(y1[1], y1[2]+1)
# Vector con las posiciones de los ticks.
  ticksat <- as.vector(sapply(pow, function(p) (1:10)*10^p))
# Drawing the axis (main ticks)
  axis(2, 10^pow)
# Drawing the axis (secondary ticks)
  axis(2, ticksat, labels = NA, tcl = -0.25, lwd = 0, lwd.ticks = 1)
}
```

```{r fig.height = 15, fig.width = 8}
# Let's actually draw the graphs.

par(mfcol = c(3, 1))

# Egg retrievals by clinic
x <- clinic_data[,22:26]
log_boxplot(x,xlab = "Age groups", ylab = "Egg Retrievals by Clinic",
        main = "Egg Retrievals by Clinic and Age Group",
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "aliceblue")

# Ratio of retrievals resulting in live births
boxplot(clinic_data[c(27:31)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Retrievals Resulting in Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "lightgoldenrod1")

# Ratio of retrievals resulting in singleton live births
boxplot(clinic_data[c(32:36)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Retrievals Resulting in Singleton Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "coral")
```

I have had some problems with this image. Labels and points are more little than I wanted, but at least I have managed to include all three graphs into the same image.


## Transfers

**Transfer** is a procedure in which an embryo is transferred, from laboratory culture, to the uterus.

Live above, we will represent number of transfers, percentage of transfers resulting in live births, and those resulting in singleton live births.

```{r fig.height = 15, fig.width = 8}

par(mfcol = c(3, 1))

# Number of transfers
x <- clinic_data[,37:41]
log_boxplot(x,xlab = "Age groups", ylab = "Transfers by Clinic",
        main = "Number of Transfers by Clinic and Age Group",
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "aliceblue")

# Ratio of transfers resulting in live births
boxplot(clinic_data[c(42:46)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Transfers Resulting in Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "lightgoldenrod1")

# Ratio of transfers resulting in singleton live births
boxplot(clinic_data[c(47:51)],
        xlab = "Age groups",
        ylab = "Ratio",
        main = bquote("Ratio of Transfers Resulting in Singleton Live Births \nby Hospital and Age Group"),
        names = c("<35", "35-37", "38-40", "41-42", ">=43"),
        col = "coral")
```

Look at the median value of the percentage of transfers resulting in live births for the >=43 years age group. It is zero. If we look up the value of the mean, it is a just bit better with 0.11.

All in all, even the median ratio for the youngest age group is not that great, a tad under 0.5 (0.48).